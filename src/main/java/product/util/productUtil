/**
 * <pre>
 * Copyright (c) 2015 SamsungSDS, Inc.
 * All right reserved.
 *
 * This software is the confidential and proprietary information of Samsung
 * SDS, Inc. You shall not disclose such Confidential Information and
 * shall use it only in accordance with the terms of the license agreement
 * you entered into with SamsungSDS.
 * </pre>
 */

package com.sds.ioffice.common.adm.utl;

import java.io.IOException;
import java.security.SecureRandom;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.servlet.http.HttpServletRequest;

import org.jsoup.Jsoup;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.sds.ioffice.common.adm.utl.enums.AdminResultCode;
import com.sds.ioffice.common.adm.utl.exception.AdminRuntimeException;

/**
 * 유틸성 함수 모음
 * 
 * @author  : SDS
 * @since 1.0
 * @see
 */
public class AdminUtil {

	private static final Logger LOGGER = LoggerFactory.getLogger(AdminUtil.class);
	private static final String PAGE 			= "page";
	private static final String ORDER_PARAM		= "orderParam";
	private static final String OPTION			= "option";

	/**
	 * Request에서 파라미터를 뽑는 유틸함수
	 * 
	 * @author SDS
	 * @see
	 * @param request
	 * @return
	 */
	public static Map<String, Object> getPageParams(HttpServletRequest request) {

		Map<String, Object> reqParams = new HashMap<String, Object>();
		boolean isSearchConvertCase = false;

		if (Constants.HTTP_REQUEST_METHOD_GET.equals(request.getMethod())) {
			String queryString = request.getQueryString();
			if (queryString != null && queryString.indexOf(PAGE) != -1 && queryString.indexOf("_") != -1) {
				isSearchConvertCase = true;
			}
		}

		for (Object key : request.getParameterMap().keySet()) {
			String keyStr = (String) key;
			Object obj = request.getParameter(keyStr);
			String parameter = obj.toString();

			if (parameter != null && !"".equals(parameter)) {
				if (isSearchConvertCase) {
					obj = obj.toString().replaceAll("%", "\\\\%").replaceAll("_", "\\\\_");
				}
			}
			reqParams.put(keyStr, obj);
		}

		//LIMIT ((페이지 번호-1)*페이지당 게시물 수) +1) ,페이지당 게시물 수
		if (request.getParameter(PAGE) != null && !request.getParameter(PAGE).equals("")) {
			int page = Integer.parseInt(request.getParameter(PAGE));
			int limit = Integer.parseInt(request.getParameter("limit"));
			page = (page - 1) * limit;
			reqParams.put(PAGE, page);
			reqParams.put("limit", limit);
		}

		if (reqParams.get(ORDER_PARAM) != null && !"".equals(reqParams.get(ORDER_PARAM))) {
			reqParams.put(ORDER_PARAM, reqParams.get(ORDER_PARAM).toString().replaceAll("\\\\", ""));
		}

		if (reqParams.get(OPTION) != null && !"".equals(reqParams.get(OPTION))) {
			reqParams.put(OPTION, reqParams.get(OPTION).toString().replaceAll("\\\\", ""));
		}

		// _dc : Extjs 에서 disabling cache를 위해 넘기는 timestamp로 사용하지 않으므로 삭제
		if (reqParams.containsKey("_dc")) {
			reqParams.remove("_dc");
		}

		return reqParams;
	}

	public static String getRandomPswd() {
		SecureRandom rnd = new SecureRandom();
		char[] posChar = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
		        'y', 'z' };
		int pswdSize = 10;

		StringBuffer tmpPswd = new StringBuffer(pswdSize);
		for (int i = 0; i < pswdSize; i++) {
			tmpPswd.append(posChar[rnd.nextInt(posChar.length)]);
		}

		return tmpPswd.toString();
	}

	@SuppressWarnings("unchecked")
	public static Map<String, Object> convertObjectToMap(Object object) {

		ObjectMapper mapper = new ObjectMapper();
		mapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);

		Map<String, Object> returnMap = mapper.convertValue(object, Map.class);

		return returnMap;
	}

	public static <T>List<Map<String, Object>> convertObjectListToMapList(List<T> objectList) {

		List<Map<String, Object>> returnList = new ArrayList<Map<String, Object>>();

		for (T object : objectList) {
			Map<String, Object> map = convertObjectToMap(object);
			returnList.add(map);
		}

		return returnList;
	}

	@SuppressWarnings("unchecked")
	public static List<Map<String, Object>> convertListParameter(Object data) {
		List<Map<String, Object>> list = null;
		if (data instanceof List) {
			list = (List<Map<String, Object>>) data;
		} else {
			list = new ArrayList<Map<String, Object>>();
			list.add((Map<String, Object>) data);
		}
		return list;
	}

	public static boolean isValidEmailFormat(String emailAddr) {
		if (!emailAddr.contains("@")) {
			throw new AdminRuntimeException(AdminResultCode.ADMIN_INVALID_FORMAT_USER_EMAIL_ADDR);
		}

		return true;
	}

	public static long convertStrToTimestamp(String str, String format, int timeDiff) {
		if (str == null || str.isEmpty()) {
			throw new AdminRuntimeException("=== Date Parsing ERROR str [" + str + "] format [" + format + " ] ===");
		}

		SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.ENGLISH);
		sdf.setTimeZone(TimeZone.getTimeZone("GMT"));

		Date parsedDate = null;

		try {
			parsedDate = sdf.parse(str);
		} catch (ParseException e) {
			throw new AdminRuntimeException("=== Date Parsing ERROR str [" + str + "] format [" + format + " ] ===");
		}

		return parsedDate.getTime() - (Long.valueOf(timeDiff * Constants.ONE_MINUTE_IN_MILLISECONDS));
	}

	
	public static String convertTimestampToStr(long timestamp, String format, int timeDiff) {
		SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.ENGLISH);

		Date timeDiffDate = new Date(convertTimestampToTimestamp(timestamp, timeDiff));
		
		return sdf.format(timeDiffDate).toString();		
		
	}
	
	public static String convertTimestampToStr(long timestamp, int timeDiff) {
				
		return convertTimestampToStr(timestamp, "yyyy-MM-dd HH:mm:ss", timeDiff);
	}
	
	public static long convertTimestampToTimestamp(long timestamp, int timeDiff) {
		Date timeDiffDate = new Date(timestamp + Long.valueOf(timeDiff * Constants.ONE_MINUTE_IN_MILLISECONDS));
		return timeDiffDate.getTime();
	}

	public static String convertDtmWithTimeDiff(String dtmString, int timeDiff) {

		if (dtmString == null || dtmString.length() == 0 || "0000-00-00 00:00:00".equals(dtmString)) {
			return "";
		}

		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ENGLISH);

		Date timeDiffDate = null;
		try {
			timeDiffDate = sdf.parse(dtmString);
		} catch (ParseException e) {
			throw new AdminRuntimeException(AdminResultCode.ADMIN_DATE_PARSE_EXCEPTION);
		}

		Calendar cal = Calendar.getInstance();
		cal.setTime(timeDiffDate);

		cal.add(Calendar.MINUTE, timeDiff);

		return sdf.format(cal.getTime());
	}

	public static <T>List<T> convertJsonToList(String json) {
		if ("".equals(json)) {
			return null;
		}
		ObjectMapper objectMapper = new ObjectMapper();
		try {
			TypeReference<List<T>> typeReference = new TypeReference<List<T>>() {
			};
			return objectMapper.readValue(json, typeReference);
		} catch (IOException e) {
			LOGGER.error("Error converting Json to Map .", e);
		}

		return null;
	}

	public static String convertObjectToJson(Object dataObject) {
		ObjectMapper objectMapper = new ObjectMapper();
		objectMapper.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);
		objectMapper.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false);

		String jsonString = null;
		try {
			jsonString = objectMapper.writeValueAsString(dataObject);
		} catch (IOException e) {
			LOGGER.debug("Exception e {}", e);
		}

		return jsonString;
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static String getJsonContent(String str) {
		String type = "";

		if (str.indexOf("{") == -1 || str.length() < 2 || "{}[]".equals(str)) {
			return str;
		}

		StringBuilder result = new StringBuilder();
		try {
			List<Object> list = convertJsonToList(str);
			for (int i = 0; i < list.size(); i++) { // List1
				if (list.get(i) instanceof List) {
					List<Object> list1 = (List<Object>) list.get(i);
					for (int j = 0; j < list1.size(); j++) { // List2
						if (list1.get(j) instanceof List) {
							List list2 = (List) list1.get(j);
							for (int k = 0; k < list2.size(); k++) { // List3
								type = ((Map) list2.get(k)).get("type").toString();
								if ("text".equals(type)) {
									result.append(((Map) list2.get(k)).get("content"));
								} else if ("mention".equals(type)) {
									result.append(((Map) list2.get(k)).get("srchRlstNm"));
								}
								result.append(" ");
							}
						} else {
							type = ((Map) list1.get(j)).get("type").toString();
							if ("text".equals(type)) {
								result.append(((Map) list1.get(j)).get("content"));
							} else if ("mention".equals(type)) {
								result.append(((Map) list1.get(j)).get("srchRlstNm"));
							}
						}
					}
				} else {
					type = ((Map) list.get(i)).get("type").toString();
					if ("text".equals(type)) {
						result.append(((Map) list.get(i)).get("content"));
					} else if ("mention".equals(type)) {
						result.append(((Map) list.get(i)).get("srchRlstNm"));
					}
					result.append(" ");
				}
				result.append("<br>");
			}
			return result.toString();
		} catch (Exception e) {
			LOGGER.debug("Create Audit Fail", e);
			return str;
		}
	}

	public static String convertXSS(String origin) {
		if (origin == null) {
			return "";
		}
		Pattern pattern = Pattern.compile("(?i)<[^>]*on[a-z]+[^>]*>");
		Matcher matcher = pattern.matcher(origin);
		StringBuilder sb = new StringBuilder();
		int index = 0;
		while (matcher.find()) {
			sb.append(origin.substring(index, matcher.start()));
			sb.append(matcher.group().replaceAll("(?i)on[a-z]+=", "destroy-event="));
			index = matcher.end();
		}
		String cleanedStr = sb.append(origin.substring(index, origin.length())).toString();
		
		return cleanedStr.replaceAll("javascript:", "destroy-tag");
	}

	public static String getTextInHtml(String html) {
		String text = "";
		if( html != null ){
			text = Jsoup.parse(html).text().replace((char)160, (char)32);
		}
		return text;
	}
	
	public static <K,V> Map<K,V> getMapFromJson(String jsonObject , Class<K> k, Class<V> v) {
		ObjectMapper om = new ObjectMapper();
		try {
			return om.readValue(jsonObject, new TypeReference<Map<K,V>>() {});
		} catch (IOException e) {
			LOGGER.info("Exception e {}", e);
		}
		return new HashMap<>();
		
	}
	
	public static Map<String, Object> createParam() {
		Map<String, Object> param = new HashMap<>();
		param.put("coCdVal", UserContext.getCoCdVal());
		param.put("langCd", UserContext.getLangCd());
		
		return param;
	}
	
	/**
	 * XSS 필터 적용
	 * 
	 * @author 
	 * @see
	 * @return 필터적용된 String
	 */
	public static final String cleanXSS(String param) {
		if (param == null || "".equals(param)) {
			return param;
		}

		String orgText = param;

		String[] dangerousTexts = { "eval\\((.*)\\)", "[\\\"\\\'][\\s]*javascript:(.*)[\\\"\\\']", "<script", "<iframe",
		        "<img", "<Embed", "<iframe", "document.cookie", "document.location", "document.write", "window.open",
		        "window.location", "href="
				// A HREF
		};
		for (int i = 0; i < dangerousTexts.length; i++) {
			String dangerousText = dangerousTexts[i];
			String tempOrgText = orgText.replace(" ", "").toLowerCase();
			if (tempOrgText.contains(dangerousText)) {
				if ("<!--".equals(dangerousText)) { //기관별양식을 html로 업로드 할경우 <!--이 포함되어있을 수 있고 그 경우 <!--에 대해서만 <를 &lt;로 변경함...
					orgText = orgText.replaceAll("<!--", "&lt;!--").replaceAll("-->", "--&gt;");
				} else if (orgText.contains("<")) {
					orgText = orgText.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
				} else {
					orgText = orgText.replaceAll(dangerousText, "");
				}
			}

		}
		return orgText;
	}
	
	public static boolean hasInvalidCharacterInStr(String str) {
		String regEx = ".*[*?:\\|/<>].*";
		Pattern pattern = Pattern.compile(regEx);
		Matcher matcher = pattern.matcher(str);
		
		return matcher.find();
	}
	
	public static boolean hasInvalidCharacterInStr(String str, String regEx) {
		Pattern pattern = Pattern.compile(regEx);
		Matcher matcher = pattern.matcher(str);
		
		return matcher.find();
	}
	
}
